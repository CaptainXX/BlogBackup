---
title: C++ Primer 学习笔记
category: notes
tags: [Coding]
---

- 快要开学了，一年前学的C++在这一年几乎没有怎么用的情况下快要忘光了，那么就顺势以复习C++的名义来开始这本书吧，这必定是一个知新 > 温故的过程T T。

- 这本书一共有18个章节，从第10章开始介绍`对象和类`，也是我曾经所上的非计算机类C/C++讲的很少的部分，这一部分的学习可能会比较困难，也比较缓慢。

- 这一学期的课程比较多，也比较困难，在这里先减去15，16，17三周，用来复习专业的课程。

- 那么距离开学还有两周的现在，8月26日星期天，我这一学期一共有16周的时间来看完这本书。开学前的这两周计划最少看完 **第6章 分支语句和逻辑运算符**，之后尽量挑周末或者平时课业不忙的时候，把剩下的12章看完并完成练习题，加油！

- Coding环境不打算再使用Visual Studio，而是在Linux的环境下进行编程，顺便熟悉Linux程序的编译(g++)和调试(gdb)过程，也算是**pwn**题的基础吧:D。顺便熟悉Linux的环境。

#### 2018-08-27

##### 第一章

C++98：于1998年制定出的国际C++标准，获得了ISO，IEC和ANSI的批准。

C++03：在2003年发布的C++标准第二版，对第一版进行了整理，但没有改变语言特性。所以通常用C++98表示C++98/C++2003

C++11：新增了众多特性，曾被称为C++0x。

Stroustrup 编写的《The Progamming Language》是最初的C++标准

本书会对C++98作详细的介绍，并且会涵盖C++11的新特性。


- C++程序的编写和运行

1. 使用文本编辑器编写并保存在文件中。我在此使用vim编辑器来编写。
2. 编译源码，产生程序的目标代码(object code)。
3. 将目标代码和其他代码连接起来，如标准函数库等，生成可执行的代码。

g++编译器必须加参数才能支持C++11特性：`g++ -std=c++0x use_auto.cpp`

编译器需要正确的扩展名，否则会报错：*bad magic number*

UNIX中应使用大写的字母C来作为C++程序的扩展名，某些UNIX系统也可以使用cc或者cxx。（经过测试Ubuntu中可以使用cc或cpp）

DOS系统不区分大小写，所以使用cc或cxx来区分C和C++程序



- Linux系统编译C++

使用g++来编译C++源代码`g++ s.cc`，如果只有一个源代码文件，则不会产生.o为扩展名的目标代码，而是直接产生二进制文件**a.out**。如果有多个源代码文件，则会产生目标代码文件

如果更改了其中某个源代码文件，则可以使用更改后的源代码文件和原来的目标代码文件来重新编译程序`g++ edited.cpp precious.o`。

Debug时，应首先改正第一个错误，如果在标注的行上找不到错误，那么查看前一行。

##### 第二章 开始学习C++

C++区分大小写，使用`//`进行注释。

所有的程序文件在 `/Notes/Codes` 目录中


C++中的每条语句都需要以`;`结尾，不可省略。

函数前面的部分是函数的**返回类型**，int main()表示main函数返回一个整数值，括号中的部分是形参列表，main函数由启动代码调用，而启动代码一般是由编译器添加到程序中的。

void main()函数头是不符合标准的，在有些系统上不能工作，因此要避免这种使用方式。

如果main函数到结尾没有遇到返回语句，则默认以return 0;结尾。

完整的C++程序都需要存在一个main函数，如果没有main函数，编译器会指出“未定义main()函数”，但是也存在一些例外情况

- WINDOWS中动态链接库模块，因为不是独立的程序，所以不需要main
- 专用环境的程序，如机器人的控制器芯片，可能不需要main
- 有些编程环境提供框架程序，调用一些非标准函数，如\_tmain()，这种情况下会有一个隐藏的main()来调用\_tmain()，但是常规的独立程序都需要main

C++也可以使用/\*\*/来注释



编译指令：#include <iostream>

该编译指令将iostream文件添加到程序中。编译器在编译时会用 iostream 的文件内容来替换这一语句。

类似iostream的文件称为包含文件，也称‘头文件’，C语言头文件一般以.h作为扩展名，而C++头文件去掉了扩展名。这两种头文件C++程序都可以使用。



名称空间 namespace

using namespace std;称为using编译指令，将在第9章详细介绍。

名称空间的存在意义是在编写大型程序时，可以用来区分不同版本的同名程序。

可以将不同版本的程序放在不同的名词空间中，调用时：`namespace::function`，在函数前加上名称空间::，就可以调用不同版本的函数了。

但是使用using namespace std;是一种偷懒的写法，在大型项目中更好的方法是：

```
using std::cout;
using std::endl;
using std::cin;
```

添加上述代码后即可使用 cout cin endl。而不会吧std命名空间的所有函数都添加。



C++输出：`cout << "I am a string.";`

双引号中的部分表示要打印的字符串，C++中双引号括起的字符叫字符串，`<<`表示把这个字符串发送给`cout`，或者说把一个字符串插入到输出流中。



控制符 endl

在C++中表示重启一行，使屏幕光标移到下一行开头。输入\n也有同样的效果。



C++源代码格式化。

C++因为有`;`来分割语句，所以语句之间也可以使用空格来分隔，而不是回车。但是函数名，字符串，变量名中间不可包含回车。



一行代码中不可分分割的元素称为标记(token)，不可分割的标记需要有空白来分隔。

制表符、空格、回车称为空白。



C++源码风格：

- 每条语句占一行。
- 每个函数都有一个开始花括号和一个结束花括号，两个花括号各占一行。
- 函数中的语句都相对于花括号进行缩进。
- 与函数名词相关的圆括号周围没有空白。



变量定义：`int carrots`

这条语句指出了需要的内存和该内存单元的名称。int是最基本的整数类型。

C++必须进行变量声明才可以调用。



变量赋值：`carrots = 25;`

`=`称为赋值运算符。C++可以连续使用赋值运算符。例如 `a = b = c = 10;`，赋值将从右向左进行。



cout可以输出变量，并根据变量的数据类型输出，而不用像printf一样使用%d %s等符号说明字符串或者整数。



使用`cin`,`cin >> carrots;`

>> 表示信息从cin流向变量(有点像shell)，更正式的表达是：cin使用>>从输入流中抽取字符。



cout可以将分隔符空格替换为回车，这样在比较长的输出中更容易阅读。
```
cout << "Now you have "
     << carrots
     << " carrots.\n"
```



- 类的简介

cout 是一个ostream类的对象，ostream类定义描述了它的对象表示的数据和可以对它进行的操作，如将变量插入到输出流中。

cin 也是一个istream类的对象。



我们并没有定义cout cin类，而可以使用他们，是因为它们存在于C++已有的类库中。

iostream系列类和fstream系列类是早期所有实现都自带的唯一两组类定义。

要对特定对象执行操作，需要给该对象发送一条消息。C++有两种发送消息的方法，一种是使用类方法，另一种是重新定义运算符。cin cout采用了第二种方法，也就是重新定义了 << 和 >> 运算符，来发送消息。



函数简介

C++函数分为有返回值的函数和没有返回值的函数。编译器必须知道函数的参数类型和返回值类型。C++使用函数原型语句来提供编译器这些信息。

`double sqrt(double);`表示函数返回值类型为double，需要一个double类型的参数传入。

如果上面的语句没有`;`，编译器会认为这是一个函数头，并会要求提供函数体。

通过包含文件math.h或是cmath就可以使用sqrt函数了。

在使用库函数时，编译器会搜索库函数，如果没有搜索到则会报错，例如math.h库，可以在编译时添加参数`g++ sqrt.cpp -lm`来提示。



有些函数需要多项信息，如

`pow(5.0. 8.0);`表示计算5的8次方。

还有的函数不接受任何参数，如

`int rand(void);`返回一个随机整数。



使用用户自定义的函数：

必须在main()函数前提供函数原型。

函数的格式和main()函数是相同的。都是由函数头和函数体组合而成。



关键字不能作为变量名。



当前的观念是，之让需要访问名称空间std的函数访问它是更好的选择。



C++语句类型：

- 声明语句：定义变量名称和类型
- 赋值语句：给变量赋值
- 消息语句：将消息发送给对象
- 函数调用：执行函数，被调用的函数执行完毕后，程序返回到函数调用语句后面的语句。
- 函数原型：声明函数类型，返回值类型，参数数量和类型
- 返回语句：将一个值返回给调用它的函数。




练习题

1. 类库？
2. 包含头文件，iostream
3. get approch to namespace std
4. cout << "Hello, world" << endl;
5. int cheeses;
6. cheeses = 32;
7. cin >> cheeses;
8. cout << "We have " << cheeses << " varieties of cheese.\n";
9. 函数原形语句：
  1. int froop(double t);函数名为froop，返回值类型为int，接受一个类型为double的参数
  2. void rattle(int n);函数名rattle，无返回值，接受一个int型参数
  3. int prune(void);函数名prune，返回值为int型，不接受任何参数
10. 返回值为void类型时，或定义的函数为main()函数时，不必使用return。
11. 可能1：未包含iostream，可能2：未使用std命名空间。 #include <iostream> using namespace std; or using std::cout or std::cout << "...";

- 编程题在`./codes/coding_practice_2.7`目录中。

#### 2018-08-28 

##### 第三章 处理数据

C++命名规则：

- 在名称中只能使用字母字符、数字和下划线
- 名称的第一个字符不能是数字
- 区分大小写字母
- 不能使用关键字
- 以两个下划线和大写字母打头的名称被保留给编译器及其使用的资源使用
- 以一个下划线打头的名称被保留，用作全局标识符
- C++对名词的长度没有限制

ANSI C(C99)标准只保证名称中的前63个字符有意义。

命名风格：在命名变量时，可能会在前面加上描述其数据类型的字母：

- n代表整数值
- str或sz(以空字符结束的字符串)代表字符串
- b代表布尔值
- p代表指针
- c代表单个字符



bit称为`位`

short代表至少16位整数，int 至少和short一样长，long 至少32位且至少和int一样长，long long 至少64位，且至少和 long一样长。

不同系统中整型的长度是不同的老IBM PC中 int 宽为16位，Windows XP、Windows 7等系统中，为32位。

如何查看系统对int长度的限制：

- 可以使用sizeof 运算符返回类型或变量的长度。`sizeof (int)`or `sizeof var`
- 头文件climits(limits.h)中，定义了一些符号常量来表示
  - `INT_MAX`为int的最大值
  - `CHAR_BIT`为字节的位数

Ubuntu 下：

- short	2	bytes
- int	4	bytes
- long	8	bytes
- long long 	8	bytes

与64位 WIN7不同之处是64位 WIN7下 long 的长度是4 bytes。



头文件 climits 中定义了许多符号常量。

包括：

- `CHAR_BIT` char的位数
- `XXX_MAX` XXX的最大值
- `XXX_MIN` XXX的最小值
- `SCHAR_MAX(MIN)` signed char的最大最小值
- `UXXX_MAX(MIN)` unsigned XXX 的最大最小值
- `UNIT_MAX` 才是unsigned int的最大值，而不是`UINT`



预处理器编译命令，符号常量：`#define INT_MAX 32767`（注意没有;）

编译器会寻找所有的（独立的）`INT_MAX` 并替换为 32767，这种创建符号常量的方法是C语言留下的，C++拥有const 关键字来创建



变量初始化：`int i = 10;`

即把变量声明和赋值用一条语句来进行。

可以用另一个变量，甚至表达式来初始化变量。但是在初始化新变量之前，所用的变量必须是有一个值的。

C++11的初始化方式：

- `int emus{7};` or `int emus = {7};` 这样就是将整型变量emus初始化为 7
- `int emus{};` or `int emus = {};` 大括号是空的时，相当于把变量初始化为 0



无符号类型：`unsigned`，也就是只能存储正值的数，可以增大变量的正值范围

如 `short` 的范围是 -32768 ~ +32767，而 `unsigned short` 的范围是 0 ~ 65535

如果整数的值超出了范围，将从其范围的另一侧取值，

如 `short n_short = 32767;`

`n_short = n_short + 1;`的值就会是 -32768，这就是溢出。



通常，int被设置为目标计算机而言最为自然的长度。自然长度(natural size)指计算机处理起来效率最高的长度。所以没有比较有说服力的理由的话，则应使用int

如果变量的值不可能为负，则可以使用无符号类型。

如果变量表示的整数值会大于16位整数的最大可能值，则应该使用long。这样即使程序移植到int为16位的系统上时，也不会无法正常工作。

如果要存储的值超过20亿，可以使用long long。

如果要使用大型整型数组时，则应使用short，即使int和short等长也应该使用short，如果使用int，程序被迁移至int为32位系统时，所用内存就会增大一倍。而short不受影响。

如果只要一个字节，可以使用char。



整型字面值：

C++能以三种方式来写整数：10进制，8进制和16进制。

第一位是 1-9 则表示10进制数

第一位是 0，第二位是 1-7 则表示8进制数

前两位是 0x 或 0X 则表示16进制数



默认情况下，cout输出时以10进制输出。

无论数字以什么进制书写，在计算机中都是以2进制存储的。所以使用不同进制只是为了表达上的方便。

cout 也提供了类似endl的控制符号 dec, hex, oct 来输出不同进制

输出十进制：`cout << dec << "42 in decimal " << chest << endl; `

输出八进制：`cout << oct << "42 in octal " << inseam << endl;`

输出十六进制：`cout << hex << "42 in hex " << waist << endl;`



这三个控制符号只是发送给cout的消息，用于更改显示进制，而不会再屏幕上有输出。



编译器确定常量类型：

`cout << 21022 << endl;`,编译器如何确定这个数的类型，默认储存为 int 

如果有后缀或数值太大：

首先看后缀，整数后面 l 或 L 表示long, u 或 U 表示unsigned int，uL, Ul, ul, UL 表示unsigned long。ll表示long long。

如果不带后缀

- 对于10进制数，使用 int, long, long long 中能够存储该数的最小类型来表示。
- 对于十六进制或八进制数，使用 int, unsigned int, long, unsigned long, long long, unsigned long long 中能够存储该数的最小类型来表示。十六进制常用来表示内存地址，所以常用 unsigned int来表示16位地址，而不是long



char类型：字符和小整数

char类型一般用来表示字符，因为很多系统支持的字符都不超过128个，所以用一个字节就可以表示所有的符号。

除此之外，还可以用char来表示比short更小的整型数。

本书的示例代码都是ASCII码，而C++支持的宽字符类型`wchar_t`可以存储更多的值，如Unicode字符集使用的值



C++ 对字符使用单引号，对字符串使用双引号。

使用cin输入字符时，cin会把输入的字符转化为数字存储在内存中，用cout输出时，再把数字转化为字符输出。把同样的字符赋值给 int类型的话，cout时就会显示该字符的ASCII码，也就是它在内存中存储的数字。

cout由值的类型判断如何显示值。

cout.put()函数，显示一个字符。

cout.put()是cout的一个成员函数。put是函数名。



书写字符串的方法：将字符用单引号括起。代表字符的数值编码。

使用反斜杠作为转移字符，在C++中将特殊字符变为常规字符

称为转义序列 \n 表示换行 \a 表示响铃。(Ubuntu并不支持 \a)

\v	垂直制表符：`xx \vss`将会显示：
```
xx
	ss
```

\b 退格

转义序列的处理应和常规字符相同。可以基于字符的八进制和十六进制ASCII编码来使用转移序列。

如：CTRL + Z 的 ASCII码为26，八进制 032，十六进制 0x1a，可以使用 \032或 \x1a来作为 ^Z



通用字符名：

以 \u 或 \U 打头，\u 后面是8个十六进制位，\U 后面是16个十六进制位，表示的是字符的ISO 10646码点。

来表示Unicode字符。



将char用于存储数值类型

unsigned char 范围是 0 ~ 255

signed char 范围是 -128 ~ 127



宽字符类型`wchar_t`

可以表示系统使用的最大扩展字符集。

`wchar_t`类型的底层是一种整数类型，在不同的系统中可能是不同的整型，如unsigned short 或 int.

cin cout将输入输出看作char流。不适合处理`wchar_t`类型，iostream头文件中提供了 wcin wcout来处理`wchar_t`流。

可以在字符前加上前缀 *L* 来指示宽字符常量和宽字符串 `wcout << L"tall" << endl;`



C++11新增类型：`char16_t` 和 `char32_t`

`char16_t`长 16 位，使用前缀 u 来表示 `u'C'`

`char32_t`长 32 位，使用前缀 U 来表示 `U"Good"`



bool类型

逻辑值，可以是 true 或 false

C++也将非0值解释为true，将0解释为false

true 和 false也可以解释为int类型,true被解释为1，false被解释为0

`int ans = true;` ans = 1



const限定符

`const int Months = 12;`就初始化了一个符号常量，不需要#define

常见做法是将常量的首字母大写，来提示这是一个常量。

常量必须在声明时就初始化，声明后的常量将无法修改。

使用const比使用#define更好，因为const可以限制常量的作用域，并且可以用于更复杂的数据结构。



浮点数

带小数部分的数字。

可以使用E表示法来表示很大或者很小的数字：如2.1e-6, 表示2.1x10^-6

可以从cfloat或float.h中找到系统对float等数值类型的长度限制

- float至少32位
- double至少48位，且不少于float
- long double至少和double一样多



cout通常会删除结尾的0，调用`cout.setf(ios_base::fixed, ios_base::floatfield)`使其显示出0。

cout打印6位小数。

float在第七位上就和正确值有了误差。

而double有15位有效位。

第17章会介绍cout的格式化方法。



尝试阅读头文件，这些头文件都是很好的文档。是很好的信息来源。



浮点常量

一般直接写出的浮点数,如`8.24` `2.1e10`等，都是doubel类型

在后面加F或f后缀，则使常量变为float类型。

对于long double，使用l 或 L 后缀。

float只能表示数字的前6-7位，在之后的位数上有所改变，这个数不会改变。



C++按类型分类：

- signed char, short, int, long称为符号整型
- 无符号版本的上述四种类型称为无符号整型
- C++11新增的 long long, bool, char, `wchar_t`，和上述两种类型统称为整型
- float, double, long double统称为浮点型
- 整型和浮点型统称为算术类型



C++算术运算符

\+	\-	\*	\/	\%

加	减	乘	除	取余



运算顺序，对一个操作数，先乘除，后加减，从左到右。

对多个操作数，由实现决定先作哪个。

除法中，两个整数相除，得到整数结果；有一个浮点数，则得到浮点数结果。



- 使用相同符号进行多种操作叫做：运算符重载。
- 取余运算符只能用来计算整型除法。


类型转换

C++自动执行很多类型转换：

- 将一种算术类型的值赋给另一种算术类型的变量时
- 表达时中包含不同的类型时
- 将参数传递给函数时



1. 初始化和赋值进行的转换。

将较小的类型赋值给较大的类型时，将会扩展大小，不会造成问题；

较大类型赋值给较小类型时会出现问题：

- 浮点数：精度降低，值可能超出目标类型的取值范围，结果不确定
- 浮点转换为整型：小数部分丢失，值可能超出目标类型的范围，不确定
- 整型：原来的值可能会超出目标类型的取值范围，通常只复制右边的字节。



C++11的初始化方式

以{}方式来初始化，称为列表初始化(list-initialization)

这种初始化对类型转换的要求更加严格。不允许类型缩窄(narrowing)



表达式中的转换:

- 自动转换：

C++将bool, char, unsigned char, signed char 和 short转换为int。

称为整型提升。

整型提升中，原来的类型会被提升为宽度足够存储的：符号或无符号整型。

不同类型算术运算时，较小的类型会转换为较大的类型。



C++11的校验表为：

1. 有一个long double，则将另一个操作数转换为long double
2. ...double, ...double
3. ...float, ...float
4. 操作数都是整型，则执行整型提升
5. 两个操作数都是 符号（无符号）整型，则将较低级别的转换成较高级别的
6. 一个是 符号整型， 一个是 无符号整型，且无符号操作数级别高，则转换为无符号
7. 否则, 如果 符号整型 能表示 无符号整型的所有可能取值，则转换为 符号整型
8. 否则, 将两个操作数都转换为 符号类型 的 无符号版本



- 强制转换：

例如将int 转换为long

`(long) thorn` 或 `long (thorn)`

第一种格式符合C语言，第二种是C++

C++中更为严格的转换运算符：

`static_cast<long> (thorn)`



C++11新增了工具，让编译器能够根据初始值的类型，推断变量的类型。

`auto n = 100;`
`auto x = 1.5;`
`auto y = 1.3e12L;`



复习题：

1. 长整型用于存储较长的数值，无符号整型可以在数值大于0的情况下使用相同的内存存储更多的数据，短整型可以在需要节省内存且现实允许时使用。 
2. 声明变量
- short sh = 80;
- unsigned int n = 42110;
- long long l = 3000000000;or unsigned long l = 3000000000;
3. 超出范围时从整数另一侧取值
> ans: C++没有提供这样的自动防止整型溢出的功能，可以使用climits来确定限制情况
4. 33为int ，33L为long
5. 等价。内存中都是65
> ans: 只有在使用ASCII码的系统上，才等价。
6. 1 char sh = 88; cout << sh << endl; 2 cout << char (88) << endl;
7. 不会，会
> ans: long为4字节则没有损失.
8. 结果：
- 74
- 4
- 0
- 4.5
- 3
9. `int n = int(x1) + int(x2);` `int n = int(x1 + x2);`
10. 自动类型
- int
- float
- char
- `char32_t`
- double 


#### 2018-08-29

##### 第四章 复合类型

本章包括：

- 数组、C-风格字符串、String类字符串、使用getline(), get()读取字符串
- 混合输入字符串和数字
- 结构、共用体、枚举、指针
- new, delete管理动态内存
- 动态数组、动态结构
- 自动存储、静态存储、动态存储
- vector和array类简介

内容很丰富，看的时候应该注意和旧的知识做对比，温故而知新。



- 数组：能够存储多个同类型的值的数据格式。

数组声明：

- 指出存储的数据类型
- 数组名
- 数组元素的个数

`short months[12];`

数组元素的个数必须是确定的：即在编译时就是已知的。

例如：整型常数，const符号常量，常量表达式如`8 * sizeof(int)`

不能是变量，因为变量的值是在程序运行时才设置的。本章后会讲到使用new运算符来避开这种限制。

之前对这里一直不理解，可能也是因为之前不了解程序从源码 -> 编译 -> 连接 -> 可执行文件的过程，在VS上面点一下就可以自动地完成整个过程，程序由源码直接就能运行，所以总是以为在程序里给变量赋值就可以作为数组的大小，这是编程环境的影响啊。

数组的索引（也就是使用数组元素时中括号里面的数字）从0开始，代表第一个元素。

C++不会检查索引是否有效，如果把一个值赋值给不存在的元素，编译器不会指出错误，但程序运行后会发生问题。



数组的初始化：`int yams[3] = { 6, 8, 7 };`

数组的大小是每个元素的大小乘以数组元素的数量。可以用sizeof返回



只有在声明数组时才可以用 `{}`给数组元素赋值，对已经声明的数组，只能通过索引来逐一赋值。

初始化数组时，如果 `{}` 内提供的值少于数组的元素，则只初始化了前面的几个元素，后面的元素将被自动设置为 0。

如果使用下面的命令`short total[500] = { 0 }`，就可以把整个数组中的所有元素都初始化为0

如果初始化时，`[]`内为空，则编译器将计算后面`{}`中数值的数量，来决定数组中元素的数量，如`short things[] = { 1, 2, 3, 4 };`这个数组将包含4个元素。



C++11的数组初始化方法

对于数组也可以使用列表初始化：

1. `double earnings[4] { 1.3e4, 1.6e4, 1.1e4, 1.7e4 };`省略等号

2. `unsigned int count[10] = {};`大括号中不包含任何东西，这将把所有元素设置为0，等号也可以省略

3. 禁止类型缩窄(narrowing)，例如在int型数组中，用float数值初始化元素



- 字符串

C-风格字符串：字符数组，以空字符结尾 '\0'，ASCII码值为0，用来标记字符串结尾

cout打印字符串时，直到遇到空字符才会结束，如果结尾没有空字符，就会把内存中随后的字节都作为要打印的字符，直到遇到空字符为止。

内存中的空字符很常见，所以这一过程将很快停止。



字符串的初始化：`char bird[] = "Mr. Cheeps";`

不指明字符串的大小，编译器可以自动计算。

也可以指明字符串的大小，但是必须 >= 字符的数量，如果字符数组长度大于字符串，则多余的元素会被赋值为 '\0'



C++中字符串常量("")和字符常量('')不能互换。字符常量的一种编码，ASCII系统中，'S'代表83。而"S"不是字符常量，它是 'S' 和 '\0'组成的字符串，实际上"S"代表了字符串开头的内存地址。

`char shirt_size = "S";`这一语句试图把一个地址赋值给char变量，是编译器不允许的。



拼接字符串常量：

两个用引号括起的字符串，中间有空白（空格,回车,TAB），会合并为一个，前一个字符串的'\0'将被后面一个字符串的第一个字符取代。



字符串数组

头文件cstring中的,strlen()函数，可以计算字符串的长度，但是只返回可见的字符，也就是字符串的长度，不计算'\0'，而sizeof计算的是整个字符串数组的长度。

要存储一个字符串str，字符数组的长度不能少于 strlen( str ) + 1

如果程序有多条语句使用了数组长度，那么使用符号常量来存储数组长度后，修改数组长度就变得十分简单。



- 字符串输入

使用cin输入字符串时，cin使用空白来确定字符串的结束位置，这样就无法输入带有空白的字符串。

输入带有空白的字符串时，cin只会读取第一个单词，把它存储进字符串中，其他单词则留在输入队列里，下一次调用cin时，cin就会在输入队列里发现这些单词，并再读取一个单词进入字符串。

- getline()成员函数读取整行，通过回车来确定输入结尾。

`cin.getline( str, charactercount ); `

- 第一个参数是getline要存储输入的字符串。
- 第二个参数是getline将读取的字符个数，'\0'也算，也就是说，要读取20个字符，则应在第二个参数处填上21

cin.getline()当读取了 指定数目的字符 或 读取到了 换行符 就会停止读取。

getline()读取到换行符后会丢弃换行符，不保存在输入序列中。



- get()

get()有多种变体，其中一种和getline()用法相同，但不会丢弃换行符，而是保存在输入队列中。

因此，在两次连续的cin.get()读取时，第一次输入的换行符会留在输入队列，第二个cin.get()看到的第一个字符就会是换行符，而认为没有字符可以读取，这样就会产生错误。



使用不带参数的 cin.get() 可以读取下一个字符，可以在第一次读取后调用，来处理掉换行符，以开始下一次读取。



另一种方法是，使用：`cin.get(str, count).get()`，可以这样使用的原因是，cin.get(str, count) 返回一个cin对象。

`cin.getline(str, count).getline(str2, count2)`和调用两次getline相同



C++允许函数有多个版本，条件是这些版本的参数列表不同，也就是函数的重载。

cin.getline()使输入更简单，但是老式的实现没有。

cin.get()使输入更仔细，可以检查停止读取输入的原因，是因为读到了换行符，还是因为达到了数组的边界。



空行和其他问题:

get()读取空行后将设置失效位(failbit)，接下来的输入将被阻断。

可以使用`cin.clear();`来恢复输入。

如果输入字符串比分配的空间长，则getline() 和 get()会把余下的字符留在输入队列中，getline还会设置失效位。

问题将在后面讨论。



混合输入字符串和数字

cin读取数字后，会将回车留下的换行符留在输入队列中，后面的getline()看到换行符将会认为这是一个空行，并将一个空字符串赋值给数组。

所以在cin输入数字后，在调用一次cin.get()解决掉换行符，才能读取字符串。

可以单独调用一次cin.get，也可以直接`(cin >> year).get(ch)`，ch可加可不加。



string类

要使用，必须包含头文件string，string类位于名称空间std中，必须提供一条using 编译指令或通过std::string来引用。

在很多方面，string对象的使用和字符数组相同

- 可以使用C-风格字符串来初始化
- cin 来读取输入到string
- 使用cout来显示string
- 可以使用索引来访问string对象中的字符

string对象和字符数组(也就是字符串)的主要区别时，string对象可以声明为简单变量，而不是数组。

string对象可以自动调节字符串的大小。

不能将一个数组的值赋给另一个数组

但是可以将一个string对象赋值给另一个string对象

string类简化了字符串合并操作，可以用 + 把两个string对象合并起来，还可以使用 +=



string类的其他操作

不使用string类时，也要进行复制字符串等操作。在头文件cstring中提供了这些函数。

`strcpy(charr1, charr2); // copy charr2 to charr1`
`strcat(charr1, charr2); // append contents of charr2 after charr1`

使用string类比使用字符数组更方便安全。

str.size()返回string类的字符数量。



string类I/O

未赋值的数组的内容时未知的，用strlen()得到的长度可能不是0.

而用户输入前，string的长度为0，这是未被初始化的string对象自动设置的。

将一行输入读取到string 类中的代码为`getline(cin, str);`

istream类中没有处理string类对象的方法，`cin >> str;`这样的处理方法是使用string类的一个友元函数，将在11章介绍。



其他形式字符串字面值

```
wchar_t title[] = L"Chief Astrogator";
char16_t name[] = u"Felonia Ripova";
char32_t car[] = U"Humber Super Snipe";
```

此外C++11也支持UTF-8编码，使用前缀u8来表示

C++11新增原始(raw)字符串：特殊字符将不带有其他含义，比如 \n \t "，输出时将直接输出这些字符。

`cout << R"(Jim "King" Tutt uses "\n" instead of endl.)" << endl;`

上面的语句将输出R"()" 括号中的内容，双引号也被视为普通字符

在"和(之间可以加任意基本字符，在作为标识符

`cout << R"=-*(Hahaha \n (lalala) this ) won't be the end.)=-*" << endl;`

上面的语句就是用`R"=-*/()=-*/"`作为标识符

注意：特殊字符不能增加在 "和(之间，如空格，括号，斜杠和转义序列



- 结构简介

结构是用户定义的类型，可以用来存储多种数据类型。

```c++
struct inflatable
{
	char name[20];
	float volume;
	double price;
}
```

C++ 允许在声明结构时省略关键字struct
```
struct inflatable goose; // C need the struct
inflatable vincent; // C++ dont
```

通过`.`来访问结构变量的成员`goose.name`，访问到的成员就是其类型的变量



结构的声明和初始化

1. 在main()函数内部声明，放在main函数的开头，只能被main函数访问
2. 在main()函数前声明，外部声明，可以被所有函数访问到

变量也可以在外部声明

C++不提倡使用外部变量，但是提倡使用外部结构声明

结构的初始化与数组相同

```
inflatable guest = 
{
	"captainx",
	1.88,
	29.99
};
```

或是把数值都放在一行`inflatable guest = { "captainx", 1.88, 29.99 };`也可以

C++11也可以使用列表初始化，即省略上述等号，如果大括号中没有东西，则所有变量被初始化为0，不允许缩窄类型。

string类也可以作为成员的类型，使用std::string，让结构能够访问到std名称空间。

结构可以作为参数类型传入函数，也可以作为函数的返回类型。

可以使用赋值运算符将结构赋值给另一个同类型的结构。



- 结构数组

可以创建元素为结构的数组。

初始化结构数组：

```c++
inflatable guests[2] =
{
	{"Bambi", 0.5, 21.99},
	{"Godzilla, 2000, 565.99"}
};
```

可以按自己喜欢的方式来格式化。



- 结构中的位字段

C++也允许指定占用特定位数的结构成员，方便了创建与某个硬件设备上的寄存器对应的数据结构

```c++
struct torgle_register
{
	unsigned int SN : 4;	// 4 bits for SN value
	unsigned int : 4;	// 4 bits unused
	bool goodIn : 1;	// valid input 1 bit
	bool goodTorgle : 1;	// successful torgling
};
```

可以使用一般结构的方法来初始化这些字段。



- 共用体

union 类似结构，可以存储不同数据类型，但是只能同事存储其中的一种类型。

```
union one4all
{
	int int_val;
	long long_val;
	double double_val;
};
```

可以用one4all来存储int, long or double，但是不能同时进行。

当已经存有一种类型值的union被赋予另一个类型的值时，之前的值就会被丢弃。

union的大小是能够存储的所有值中最大的。

union的用途是：在数据使用多种格式时，可以节省空间。

匿名共同体：没有名称的union，其成员是位于相同地址处的变量。



- 枚举

`enum`工具，可以用来代替const来创建符号常量。

还允许定义新类型，但必须按严格的限制进行。

`enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};`

上面的语句定义了一个枚举类型spectrum，默认将整数值赋给枚举量，从0开始依次递增。

声明的枚举变量只能被赋值为定义中包含的值，否则编译器将会报错。

枚举变量只有赋值运算符，没有其它运算符可以使用。

`spectrum band;`

如果有语句`band = orange + red;`

`orange + red`这个表达式是合法的，orange和red被转化为1和0进行计算，但是类型是int，不能赋值给band

可以通过强制类型转换，把int转化为枚举中的值，则可以赋值给枚举变量

`band = spectrum(3);`

如果对一个不在枚举值范围的int进行强制类型转换，结果将是不确定的

`band = spectrum(99999);`



设置枚举量的值

`enum bits{one = 1, two = 2, four = 4, eight =8};`可以使用赋值运算符来设置

`enum bigstep{first, second = 100, third};`可以只设置一些枚举量的值，其它的将被自动设置。



枚举值的取值范围：

最大值MAX：

1. 找到枚举量的最大值max
2. 找到一个2的幂x，x大于max，且是所有大于max的2的幂中最小的
3. MAX = x - 1;

最小值MIN：

如果最小的枚举量不小于0，则MIN = 0;

否则，按照MAX的计算方法计算，并添加负号（x-1变为 x+1）

C++增加了作用域内枚举(scoped enumeration)第十章将介绍


