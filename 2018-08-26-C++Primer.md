---
title: C++ Primer 学习笔记
category: notes
tags: [Coding]
---

- 快要开学了，一年前学的C++在这一年几乎没有怎么用的情况下快要忘光了，那么就顺势以复习C++的名义来开始这本书吧，这必定是一个知新 > 温故的过程T T。

- 这本书一共有18个章节，从第10章开始介绍`对象和类`，也是我曾经所上的非计算机类C/C++讲的很少的部分，这一部分的学习可能会比较困难，也比较缓慢。

- 这一学期的课程比较多，也比较困难，在这里先减去15，16，17三周，用来复习专业的课程。

- 那么距离开学还有两周的现在，8月26日星期天，我这一学期一共有16周的时间来看完这本书。开学前的这两周计划最少看完 **第6章 分支语句和逻辑运算符**，之后尽量挑周末或者平时课业不忙的时候，把剩下的12章看完并完成练习题，加油！

- Coding环境不打算再使用Visual Studio，而是在Linux的环境下进行编程，顺便熟悉Linux程序的编译(g++)和调试(gdb)过程，也算是**pwn**题的基础吧:D。顺便熟悉Linux的环境。

#### 2018-08-27

##### 第一章

C++98：于1998年制定出的国际C++标准，获得了ISO，IEC和ANSI的批准。

C++03：在2003年发布的C++标准第二版，对第一版进行了整理，但没有改变语言特性。所以通常用C++98表示C++98/C++2003

C++11：新增了众多特性，曾被称为C++0x。

Stroustrup 编写的《The Progamming Language》是最初的C++标准

本书会对C++98作详细的介绍，并且会涵盖C++11的新特性。


- C++程序的编写和运行

1. 使用文本编辑器编写并保存在文件中。我在此使用vim编辑器来编写。
2. 编译源码，产生程序的目标代码(object code)。
3. 将目标代码和其他代码连接起来，如标准函数库等，生成可执行的代码。

g++编译器必须加参数才能支持C++11特性：`g++ -std=c++0x use_auto.cpp`

编译器需要正确的扩展名，否则会报错：*bad magic number*

UNIX中应使用大写的字母C来作为C++程序的扩展名，某些UNIX系统也可以使用cc或者cxx。（经过测试Ubuntu中可以使用cc或cpp）

DOS系统不区分大小写，所以使用cc或cxx来区分C和C++程序



- Linux系统编译C++

使用g++来编译C++源代码`g++ s.cc`，如果只有一个源代码文件，则不会产生.o为扩展名的目标代码，而是直接产生二进制文件**a.out**。如果有多个源代码文件，则会产生目标代码文件

如果更改了其中某个源代码文件，则可以使用更改后的源代码文件和原来的目标代码文件来重新编译程序`g++ edited.cpp precious.o`。

Debug时，应首先改正第一个错误，如果在标注的行上找不到错误，那么查看前一行。

##### 第二章 开始学习C++

C++区分大小写，使用`//`进行注释。

所有的程序文件在 `/Notes/Codes` 目录中


C++中的每条语句都需要以`;`结尾，不可省略。

函数前面的部分是函数的**返回类型**，int main()表示main函数返回一个整数值，括号中的部分是形参列表，main函数由启动代码调用，而启动代码一般是由编译器添加到程序中的。

void main()函数头是不符合标准的，在有些系统上不能工作，因此要避免这种使用方式。

如果main函数到结尾没有遇到返回语句，则默认以return 0;结尾。

完整的C++程序都需要存在一个main函数，如果没有main函数，编译器会指出“未定义main()函数”，但是也存在一些例外情况

- WINDOWS中动态链接库模块，因为不是独立的程序，所以不需要main
- 专用环境的程序，如机器人的控制器芯片，可能不需要main
- 有些编程环境提供框架程序，调用一些非标准函数，如\_tmain()，这种情况下会有一个隐藏的main()来调用\_tmain()，但是常规的独立程序都需要main

C++也可以使用/\*\*/来注释



编译指令：#include <iostream>

该编译指令将iostream文件添加到程序中。编译器在编译时会用 iostream 的文件内容来替换这一语句。

类似iostream的文件称为包含文件，也称‘头文件’，C语言头文件一般以.h作为扩展名，而C++头文件去掉了扩展名。这两种头文件C++程序都可以使用。



名称空间 namespace

using namespace std;称为using编译指令，将在第9章详细介绍。

名称空间的存在意义是在编写大型程序时，可以用来区分不同版本的同名程序。

可以将不同版本的程序放在不同的名词空间中，调用时：`namespace::function`，在函数前加上名称空间::，就可以调用不同版本的函数了。

但是使用using namespace std;是一种偷懒的写法，在大型项目中更好的方法是：

```
using std::cout;
using std::endl;
using std::cin;
```

添加上述代码后即可使用 cout cin endl。而不会吧std命名空间的所有函数都添加。



C++输出：`cout << "I am a string.";`

双引号中的部分表示要打印的字符串，C++中双引号括起的字符叫字符串，`<<`表示把这个字符串发送给`cout`，或者说把一个字符串插入到输出流中。



控制符 endl

在C++中表示重启一行，使屏幕光标移到下一行开头。输入\n也有同样的效果。



C++源代码格式化。

C++因为有`;`来分割语句，所以语句之间也可以使用空格来分隔，而不是回车。但是函数名，字符串，变量名中间不可包含回车。



一行代码中不可分分割的元素称为标记(token)，不可分割的标记需要有空白来分隔。

制表符、空格、回车称为空白。



C++源码风格：

- 每条语句占一行。
- 每个函数都有一个开始花括号和一个结束花括号，两个花括号各占一行。
- 函数中的语句都相对于花括号进行缩进。
- 与函数名词相关的圆括号周围没有空白。



变量定义：`int carrots`

这条语句指出了需要的内存和该内存单元的名称。int是最基本的整数类型。

C++必须进行变量声明才可以调用。



变量赋值：`carrots = 25;`

`=`称为赋值运算符。C++可以连续使用赋值运算符。例如 `a = b = c = 10;`，赋值将从右向左进行。



cout可以输出变量，并根据变量的数据类型输出，而不用像printf一样使用%d %s等符号说明字符串或者整数。



使用`cin`,`cin >> carrots;`

>> 表示信息从cin流向变量(有点像shell)，更正式的表达是：cin使用>>从输入流中抽取字符。



cout可以将分隔符空格替换为回车，这样在比较长的输出中更容易阅读。
```
cout << "Now you have "
     << carrots
     << " carrots.\n"
```



- 类的简介

cout 是一个ostream类的对象，ostream类定义描述了它的对象表示的数据和可以对它进行的操作，如将变量插入到输出流中。

cin 也是一个istream类的对象。



我们并没有定义cout cin类，而可以使用他们，是因为它们存在于C++已有的类库中。

iostream系列类和fstream系列类是早期所有实现都自带的唯一两组类定义。

要对特定对象执行操作，需要给该对象发送一条消息。C++有两种发送消息的方法，一种是使用类方法，另一种是重新定义运算符。cin cout采用了第二种方法，也就是重新定义了 << 和 >> 运算符，来发送消息。



函数简介

C++函数分为有返回值的函数和没有返回值的函数。编译器必须知道函数的参数类型和返回值类型。C++使用函数原型语句来提供编译器这些信息。

`double sqrt(double);`表示函数返回值类型为double，需要一个double类型的参数传入。

如果上面的语句没有`;`，编译器会认为这是一个函数头，并会要求提供函数体。

通过包含文件math.h或是cmath就可以使用sqrt函数了。

在使用库函数时，编译器会搜索库函数，如果没有搜索到则会报错，例如math.h库，可以在编译时添加参数`g++ sqrt.cpp -lm`来提示。



有些函数需要多项信息，如

`pow(5.0. 8.0);`表示计算5的8次方。

还有的函数不接受任何参数，如

`int rand(void);`返回一个随机整数。



使用用户自定义的函数：

必须在main()函数前提供函数原型。

函数的格式和main()函数是相同的。都是由函数头和函数体组合而成。



关键字不能作为变量名。



当前的观念是，之让需要访问名称空间std的函数访问它是更好的选择。



C++语句类型：

- 声明语句：定义变量名称和类型
- 赋值语句：给变量赋值
- 消息语句：将消息发送给对象
- 函数调用：执行函数，被调用的函数执行完毕后，程序返回到函数调用语句后面的语句。
- 函数原型：声明函数类型，返回值类型，参数数量和类型
- 返回语句：将一个值返回给调用它的函数。




练习题

1. 类库？
2. 包含头文件，iostream
3. get approch to namespace std
4. cout << "Hello, world" << endl;
5. int cheeses;
6. cheeses = 32;
7. cin >> cheeses;
8. cout << "We have " << cheeses << " varieties of cheese.\n";
9. 函数原形语句：
  1. int froop(double t);函数名为froop，返回值类型为int，接受一个类型为double的参数
  2. void rattle(int n);函数名rattle，无返回值，接受一个int型参数
  3. int prune(void);函数名prune，返回值为int型，不接受任何参数
10. 返回值为void类型时，或定义的函数为main()函数时，不必使用return。
11. 可能1：未包含iostream，可能2：未使用std命名空间。 #include <iostream> using namespace std; or using std::cout or std::cout << "...";

- 编程题在`./codes/coding_practice_2.7`目录中。

#### 2018-08-28 

##### 第三章 处理数据

C++命名规则：

- 在名称中只能使用字母字符、数字和下划线
- 名称的第一个字符不能是数字
- 区分大小写字母
- 不能使用关键字
- 以两个下划线和大写字母打头的名称被保留给编译器及其使用的资源使用
- 以一个下划线打头的名称被保留，用作全局标识符
- C++对名词的长度没有限制

ANSI C(C99)标准只保证名称中的前63个字符有意义。

命名风格：在命名变量时，可能会在前面加上描述其数据类型的字母：

- n代表整数值
- str或sz(以空字符结束的字符串)代表字符串
- b代表布尔值
- p代表指针
- c代表单个字符



bit称为`位`

short代表至少16位整数，int 至少和short一样长，long 至少32位且至少和int一样长，long long 至少64位，且至少和 long一样长。

不同系统中整型的长度是不同的老IBM PC中 int 宽为16位，Windows XP、Windows 7等系统中，为32位。

如何查看系统对int长度的限制：

- 可以使用sizeof 运算符返回类型或变量的长度。`sizeof (int)`or `sizeof var`
- 头文件climits(limits.h)中，定义了一些符号常量来表示
  - `INT_MAX`为int的最大值
  - `CHAR_BIT`为字节的位数

Ubuntu 下：

- short	2	bytes
- int	4	bytes
- long	8	bytes
- long long 	8	bytes

与64位 WIN7不同之处是64位 WIN7下 long 的长度是4 bytes。



头文件 climits 中定义了许多符号常量。

包括：

- `CHAR_BIT` char的位数
- `XXX_MAX` XXX的最大值
- `XXX_MIN` XXX的最小值
- `SCHAR_MAX(MIN)` signed char的最大最小值
- `UXXX_MAX(MIN)` unsigned XXX 的最大最小值
- `UNIT_MAX` 才是unsigned int的最大值，而不是`UINT`



预处理器编译命令，符号常量：`#define INT_MAX 32767`（注意没有;）

编译器会寻找所有的（独立的）`INT_MAX` 并替换为 32767，这种创建符号常量的方法是C语言留下的，C++拥有const 关键字来创建



变量初始化：`int i = 10;`

即把变量声明和赋值用一条语句来进行。

可以用另一个变量，甚至表达式来初始化变量。但是在初始化新变量之前，所用的变量必须是有一个值的。

C++11的初始化方式：

- `int emus{7};` or `int emus = {7};` 这样就是将整型变量emus初始化为 7
- `int emus{};` or `int emus = {};` 大括号是空的时，相当于把变量初始化为 0



无符号类型：`unsigned`，也就是只能存储正值的数，可以增大变量的正值范围

如 `short` 的范围是 -32768 ~ +32767，而 `unsigned short` 的范围是 0 ~ 65535

如果整数的值超出了范围，将从其范围的另一侧取值，

如 `short n_short = 32767;`

`n_short = n_short + 1;`的值就会是 -32768，这就是溢出。



通常，int被设置为目标计算机而言最为自然的长度。自然长度(natural size)指计算机处理起来效率最高的长度。所以没有比较有说服力的理由的话，则应使用int

如果变量的值不可能为负，则可以使用无符号类型。

如果变量表示的整数值会大于16位整数的最大可能值，则应该使用long。这样即使程序移植到int为16位的系统上时，也不会无法正常工作。

如果要存储的值超过20亿，可以使用long long。

如果要使用大型整型数组时，则应使用short，即使int和short等长也应该使用short，如果使用int，程序被迁移至int为32位系统时，所用内存就会增大一倍。而short不受影响。

如果只要一个字节，可以使用char。



整型字面值：

C++能以三种方式来写整数：10进制，8进制和16进制。

第一位是 1-9 则表示10进制数

第一位是 0，第二位是 1-7 则表示8进制数

前两位是 0x 或 0X 则表示16进制数



默认情况下，cout输出时以10进制输出。

无论数字以什么进制书写，在计算机中都是以2进制存储的。所以使用不同进制只是为了表达上的方便。

cout 也提供了类似endl的控制符号 dec, hex, oct 来输出不同进制

输出十进制：`cout << dec << "42 in decimal " << chest << endl; `

输出八进制：`cout << oct << "42 in octal " << inseam << endl;`

输出十六进制：`cout << hex << "42 in hex " << waist << endl;`



这三个控制符号只是发送给cout的消息，用于更改显示进制，而不会再屏幕上有输出。



编译器确定常量类型：

`cout << 21022 << endl;`,编译器如何确定这个数的类型，默认储存为 int 

如果有后缀或数值太大：

首先看后缀，整数后面 l 或 L 表示long, u 或 U 表示unsigned int，uL, Ul, ul, UL 表示unsigned long。ll表示long long。

如果不带后缀

- 对于10进制数，使用 int, long, long long 中能够存储该数的最小类型来表示。
- 对于十六进制或八进制数，使用 int, unsigned int, long, unsigned long, long long, unsigned long long 中能够存储该数的最小类型来表示。十六进制常用来表示内存地址，所以常用 unsigned int来表示16位地址，而不是long



char类型：字符和小整数

char类型一般用来表示字符，因为很多系统支持的字符都不超过128个，所以用一个字节就可以表示所有的符号。

除此之外，还可以用char来表示比short更小的整型数。

本书的示例代码都是ASCII码，而C++支持的宽字符类型`wchar_t`可以存储更多的值，如Unicode字符集使用的值



C++ 对字符使用单引号，对字符串使用双引号。

使用cin输入字符时，cin会把输入的字符转化为数字存储在内存中，用cout输出时，再把数字转化为字符输出。把同样的字符赋值给 int类型的话，cout时就会显示该字符的ASCII码，也就是它在内存中存储的数字。

cout由值的类型判断如何显示值。

cout.put()函数，显示一个字符。

cout.put()是cout的一个成员函数。put是函数名。



书写字符串的方法：将字符用单引号括起。代表字符的数值编码。

使用反斜杠作为转移字符，在C++中将特殊字符变为常规字符

称为转义序列 \n 表示换行 \a 表示响铃。(Ubuntu并不支持 \a)

\v	垂直制表符：`xx \vss`将会显示：
```
xx
	ss
```

\b 退格

转义序列的处理应和常规字符相同。可以基于字符的八进制和十六进制ASCII编码来使用转移序列。

如：CTRL + Z 的 ASCII码为26，八进制 032，十六进制 0x1a，可以使用 \032或 \x1a来作为 ^Z



通用字符名：

以 \u 或 \U 打头，\u 后面是8个十六进制位，\U 后面是16个十六进制位，表示的是字符的ISO 10646码点。

来表示Unicode字符。



将char用于存储数值类型

unsigned char 范围是 0 ~ 255

signed char 范围是 -128 ~ 127



宽字符类型`wchar_t`

可以表示系统使用的最大扩展字符集。

`wchar_t`类型的底层是一种整数类型，在不同的系统中可能是不同的整型，如unsigned short 或 int.

cin cout将输入输出看作char流。不适合处理`wchar_t`类型，iostream头文件中提供了 wcin wcout来处理`wchar_t`流。

可以在字符前加上前缀 *L* 来指示宽字符常量和宽字符串 `wcout << L"tall" << endl;`



C++11新增类型：`char16_t` 和 `char32_t`

`char16_t`长 16 位，使用前缀 u 来表示 `u'C'`

`char32_t`长 32 位，使用前缀 U 来表示 `U"Good"`



bool类型

逻辑值，可以是 true 或 false

C++也将非0值解释为true，将0解释为false

true 和 false也可以解释为int类型,true被解释为1，false被解释为0

`int ans = true;` ans = 1



const限定符

`const int Months = 12;`就初始化了一个符号常量，不需要#define

常见做法是将常量的首字母大写，来提示这是一个常量。

常量必须在声明时就初始化，声明后的常量将无法修改。

使用const比使用#define更好，因为const可以限制常量的作用域，并且可以用于更复杂的数据结构。



浮点数

带小数部分的数字。

可以使用E表示法来表示很大或者很小的数字：如2.1e-6, 表示2.1x10^-6

可以从cfloat或float.h中找到系统对float等数值类型的长度限制

- float至少32位
- double至少48位，且不少于float
- long double至少和double一样多



cout通常会删除结尾的0，调用`cout.setf(ios_base::fixed, ios_base::floatfield)`使其显示出0。

cout打印6位小数。

float在第七位上就和正确值有了误差。

而double有15位有效位。

第17章会介绍cout的格式化方法。



尝试阅读头文件，这些头文件都是很好的文档。是很好的信息来源。



浮点常量

一般直接写出的浮点数,如`8.24` `2.1e10`等，都是doubel类型

在后面加F或f后缀，则使常量变为float类型。

对于long double，使用l 或 L 后缀。

float只能表示数字的前6-7位，在之后的位数上有所改变，这个数不会改变。



C++按类型分类：

- signed char, short, int, long称为符号整型
- 无符号版本的上述四种类型称为无符号整型
- C++11新增的 long long, bool, char, `wchar_t`，和上述两种类型统称为整型
- float, double, long double统称为浮点型
- 整型和浮点型统称为算术类型



C++算术运算符

\+	\-	\*	\/	\%

加	减	乘	除	取余



运算顺序，对一个操作数，先乘除，后加减，从左到右。

对多个操作数，由实现决定先作哪个。

除法中，两个整数相除，得到整数结果；有一个浮点数，则得到浮点数结果。



- 使用相同符号进行多种操作叫做：运算符重载。
- 取余运算符只能用来计算整型除法。


类型转换

C++自动执行很多类型转换：

- 将一种算术类型的值赋给另一种算术类型的变量时
- 表达时中包含不同的类型时
- 将参数传递给函数时



1. 初始化和赋值进行的转换。

将较小的类型赋值给较大的类型时，将会扩展大小，不会造成问题；

较大类型赋值给较小类型时会出现问题：

- 浮点数：精度降低，值可能超出目标类型的取值范围，结果不确定
- 浮点转换为整型：小数部分丢失，值可能超出目标类型的范围，不确定
- 整型：原来的值可能会超出目标类型的取值范围，通常只复制右边的字节。



C++11的初始化方式

以{}方式来初始化，称为列表初始化(list-initialization)

这种初始化对类型转换的要求更加严格。不允许类型缩窄(narrowing)



表达式中的转换:

- 自动转换：

C++将bool, char, unsigned char, signed char 和 short转换为int。

称为整型提升。

整型提升中，原来的类型会被提升为宽度足够存储的：符号或无符号整型。

不同类型算术运算时，较小的类型会转换为较大的类型。



C++11的校验表为：

1. 有一个long double，则将另一个操作数转换为long double
2. ...double, ...double
3. ...float, ...float
4. 操作数都是整型，则执行整型提升
5. 两个操作数都是 符号（无符号）整型，则将较低级别的转换成较高级别的
6. 一个是 符号整型， 一个是 无符号整型，且无符号操作数级别高，则转换为无符号
7. 否则, 如果 符号整型 能表示 无符号整型的所有可能取值，则转换为 符号整型
8. 否则, 将两个操作数都转换为 符号类型 的 无符号版本



- 强制转换：

例如将int 转换为long

`(long) thorn` 或 `long (thorn)`

第一种格式符合C语言，第二种是C++

C++中更为严格的转换运算符：

`static_cast<long> (thorn)`



C++11新增了工具，让编译器能够根据初始值的类型，推断变量的类型。

`auto n = 100;`
`auto x = 1.5;`
`auto y = 1.3e12L;`



复习题：

1. 长整型用于存储较长的数值，无符号整型可以在数值大于0的情况下使用相同的内存存储更多的数据，短整型可以在需要节省内存且现实允许时使用。 
2. 声明变量
- short sh = 80;
- unsigned int n = 42110;
- long long l = 3000000000;or unsigned long l = 3000000000;
3. 超出范围时从整数另一侧取值
> ans: C++没有提供这样的自动防止整型溢出的功能，可以使用climits来确定限制情况
4. 33为int ，33L为long
5. 等价。内存中都是65
> ans: 只有在使用ASCII码的系统上，才等价。
6. 1 char sh = 88; cout << sh << endl; 2 cout << char (88) << endl;
7. 不会，会
> ans: long为4字节则没有损失.
8. 结果：
- 74
- 4
- 0
- 4.5
- 3
9. `int n = int(x1) + int(x2);` `int n = int(x1 + x2);`
10. 自动类型
- int
- float
- char
- char32_t
- double 



